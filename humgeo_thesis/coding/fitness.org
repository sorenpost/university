#+TITLE: Algorithms
#+AUTHOR: SÃ¸ren Post
#+LATEX_HEADER: \setlength{\parskip}{1em} % set spaces between paragraphs to 1 character
#+LATEX_HEADER: \setlength{\parindent}{0em} % set indents for new paragraphs to 0
#+LATEX_HEADER: \usepackage{natbib}
#+LATEX_HEADER: \usepackage[a4paper, total={6in, 8in}]{geometry}
#+SETUPFILE: ./org-html-themes/setup/theme-readtheorg.setup
* TODO Revealed Comparative Advantage per capita
The per capita version of the RCA substitutes the reference distribution with population. That is, the RCA instead measures a countries export value per capita for a product divided by the global export value of the product per capita (ie. world population). There is a few benefits of this. First, it lessons the importance of price movements in a few products having large effects on the RCA of others (it is still not completely removed). Second, on a more practiacal note, it removes the divide-by-zero problem in the traditional equation.

Revealed Comparative Advantage per capita ($RCA^{pc}$) for country $c$ in product $p$ is defined as fined as:

$$ RCA_{cp}^{pc} = \frac{X_{cp}}{pop_c} / \frac{\sum_c X_{cp}}{\sum_c pop_c} $$

where $X_{cp}$ is a country by product matrix where the elements is the dollar amount of exports a country exports of a product (in the given year). $pop_c$ is the total population in the given year.

We implement the formula rather simply. First we build the $X_{cp}$ matrix and divide the $pop_c$ vector into it column wise (so that each countries exports are divided by its population). This gives us a population adjusted version of the $X_{cp}$ matrix. Next we take the column sums $X_{cp}$. This gives us a $p$-length vector of total global exports for each product. This vector is divided by the totalt global population. Now we have a country by product adjusted export matrix and a population adjust total export vector. Now remains just to divide the adjusted export matrix by the adjusted global export vector product wise.

Thus, if we take red wine as an example, the $RCA^{pc}$ measures the ration between a country's export of red wine divided the country's population, and the global export of red wine divided by the global population.

* Implementation
First I create a sample X matrix.

#+BEGIN_SRC R :session rca :exports both
set.seed(1)

X <- matrix(
  round(runif(12, 1, 100), 0),
  ncol = 4,
  nrow = 3,
  dimnames = list(c("c1", "c2", "c3"), c("p1", "p2", "p3", "p4"))
  )

#+END_SRC

#+RESULTS:
| 27 | 91 | 95 |  7 |
| 38 | 21 | 66 | 21 |
| 58 | 90 | 63 | 18 |


and a sample population vector.

#+BEGIN_SRC R :session rca :exports both
set.seed(1)
pop_vec <- round(runif(3, 30, 100), 0)
#+END_SRC

#+RESULTS:
| 49 |
| 56 |
| 70 |

I then find the population adjusted X matrix. Because I just need to multiply the vector into the X matrix (and not sum it afterwards), I cannot do straight up matrix-vector multiplication. I therefor turn pop into a matrix, POP, with the same dimensions as X, where each column is the current pop vector.

$$ pop = \begin{bmatrix} 49 \\ 56 \\ 70 \end{bmatrix} \rightarrow POP =  \begin{bmatrix} 49 & 49 & 49  & 49\\ 56 & 56 & 56 & 56\\ 70 & 70 & 70 & 70 \end{bmatrix} $$

Thus, when I divide $X_{cp}$ with $POP$, I get the following:

$$ \frac{X_{cp}}{POP} =  \begin{bmatrix} 27 & 91 & 95 & 7 \\ 38 & 21 & 66 & 21 \\ 58 & 90 & 63 & 18 \end{bmatrix} / \begin{bmatrix} 49 & 49 & 49  & 49\\ 56 & 56 & 56 & 56\\ 70 & 70 & 70 & 70 \end{bmatrix} = \begin{bmatrix} 27 / 49  & 91 / 49 & 95 / 49 & 7 / 49 \\ 38 / 56  & 21 / 56  & 66 / 56  & 21 / 56  \\ 58 / 70 & 90 / 70 & 63 / 70 & 18 / 70 \end{bmatrix} = \begin{bmatrix} 0.55 & 1.86 & 1.94 & 0.14 \\ 0.68 & 0.38 & 1.18 & 0.38 \\ 0.83 & 1.29 & 0.9 & 0.26 \end{bmatrix} $$

In R:

#+BEGIN_SRC R :session rca :exports both
POP_mat <- matrix(pop_vec,
                  ncol = 4,
                  nrow = 3,
                  byrow = FALSE)


round(X / POP_mat, 2)
#+END_SRC

#+RESULTS:
| 0.55 | 1.86 | 1.94 | 0.14 |
| 0.68 | 0.38 | 1.18 | 0.38 |
| 0.83 | 1.29 |  0.9 | 0.26 |

I now turn to the denominator. First I create the global product vector by taking the column sums of the original $X_{cp}$. I then just sum the $pop$ vector to give me the global population.

\begin{align}
\sum_c X_{cp} &= \begin{bmatrix} 123 & 202 & 224 & 46 \end{bmatrix} \\
\sum_c pop_c &= 175
\end{align}

Column sums in R:

#+BEGIN_SRC R :session rca :exports both
colSums(X)
#+END_SRC

#+RESULTS:
| 123 |
| 202 |
| 224 |
|  46 |

Global population in R:

#+BEGIN_SRC R :session rca :exports both
sum(pop_vec)
#+END_SRC

#+RESULTS:
: 175

I now just divide the global export value of each product with the global population scalar:

$$ \frac{\sum_c X_cp}{\sum_c pop_c} = \begin{bmatrix} 123 / 175 & 202 / 175 & 224 / 175 & 46 / 175 \end{bmatrix} = \begin{bmatrix} 0.70 & 1.15 & 1.28 & 0.26 \end{bmatrix} $$

#+BEGIN_SRC R :session rca :exports both
round(colSums(X) / sum(pop_vec), 2)
#+END_SRC

#+RESULTS:
|  0.7 |
| 1.15 |
| 1.28 |
| 0.26 |

Now I turn to the final calculation, the division between the local product export adjusted by local population and the global product export adjusted by global population. Since the nominator is a matrix and the denominator is a vector of the products on a global scale, I turn the denominator into a matrix of identical rows. This means that each product is divided by the same factor (its global export divided by global population). Thus the vector from above is stacked on it self:

$$ \begin{bmatrix} 0.70 & 1.15 & 1.28 & 0.26 \\  0.70 & 1.15 & 1.28 & 0.26 \\ 0.70 & 1.15 & 1.28 & 0.26 \end{bmatrix} $$

#+BEGIN_SRC R :session rca :exports both
matrix(round(colSums(X) / sum(pop_vec), 2), ncol = 4, nrow = 3, byrow = TRUE)
#+END_SRC

#+RESULTS:
| 0.7 | 1.15 | 1.28 | 0.26 |
| 0.7 | 1.15 | 1.28 | 0.26 |
| 0.7 | 1.15 | 1.28 | 0.26 |

Finally, I do the element-wise division of the nominator matrix (the local export in each product divided by local population) and the denominator matrix (global export in each product divided by global population). The result is a county by product matrix containing the RCA per capita values.

\begin{align}
RCA_{cp}^{pc} &= \frac{X_{cp}}{pop_c} / \frac{\sum_c X_{cp}}{\sum_c pop_c} \\
              &=  \begin{bmatrix} 0.55 & 1.86 & 1.94 & 0.14 \\ 0.68 & 0.38 & 1.18 & 0.38 \\ 0.83 & 1.29 & 0.9 & 0.26 \end{bmatrix} / \begin{bmatrix} 0.70 & 1.15 & 1.28 & 0.26 \\  0.70 & 1.15 & 1.28 & 0.26 \\ 0.70 & 1.15 & 1.28 & 0.26 \end{bmatrix}
\end{align}

#+BEGIN_SRC R :session rca :exports both
round((round(X / POP_mat, 2)) / matrix(round(colSums(X) / sum(pop_vec), 2), ncol = 4, nrow = 3, byrow = TRUE), 2)
#+END_SRC

#+RESULTS:
| 0.79 | 1.62 | 1.52 | 0.54 |
| 0.97 | 0.33 | 0.92 | 1.46 |
| 1.19 | 1.12 |  0.7 |    1 |

And that's it.

** Coding
We start with the same X matrix and pop vector as above:

#+BEGIN_SRC R
set.seed(1)

X <- matrix(
  round(runif(12, 1, 100), 0),
  ncol = 4,
  nrow = 3,
  dimnames = list(c("c1", "c2", "c3"), c("p1", "p2", "p3", "p4"))
  )

set.seed(1)

pop_vec <- round(runif(3, 30, 100), 0)


rca_pc <- function(export_mat, population_vector) {

# check for types
if(!is.matrix(population_vector)) {
stop("The population_vector is not a matrix. It needs to be a matrix with the same number of rows as the export matrix and 1 column. The rownames needs to be the country names (in the same order and format as the export matrix).")
}

if(!is.matrix(export_mat)) {
stop("The population_mat is not a matrix. It needs to be a country (row) by product (col) matrix. The rownames needs to be the country names (in the same order and format as the population_vector).")
}
 
# check for NA values
if(sum(is.na(export_mat) != 0 | sum(is.na(population_vector)) != 0) {
stop("NA values exist in either the export matrix or the population_vector. This is not allowed. Stopping.")
}

# check for the same number of countries in export matrix and population vector
if(!identical(rownames(export_mat), rownames(population_vector))) {
stop("The rownames of the export_mat and the population_vector are not identical. Stopping.")
}

# check for the dimensions of the population_vector and the export matrix
if(dim(pop) != c(nrow(export_mat), 1)){
stop("The population_vector does not have the correct dimensions. It needs to be a matrix with the same number of rows as the export matrix and 1 column.")
}

# ending function
}


POP_mat <- matrix(pop_vec,
                  ncol = 4,
                  nrow = 3,
                  byrow = FALSE)


round(X / POP_mat, 2)

# local exports adjusted by pop
local_exports_pc <-
global_exports_pc <-

#+END_SRC

* DONE Fitness algorithm 2012

The fitness algorithm is developed in cite:tacchella_new_2012-1,tacchella_economic_2013-2. The algorithm is an iterative process, where each iteration leverages the information from the previous to "refine" the information on which countries are the most fit and which products are the most complex. Basically, the most fit countries are those that export the most complex products, and the most complex products are those that are exported by the fittest countries. The main novelty of the fitness algorithm (compared to the Method of Reflections) is the insight that because many advanced countries export all kinds of products, but that less developed countries only export less complex products, there is more information in whether a less-fit country exports a product than if a more fit country does. Therefor, there is a non-linear penalty  to a product's complexity by having less fit countries export it (where the penalty is greater, the less fit the country is).

At each iteration $n$ the algorithm is defined as:

\begin{cases}
\hat{F}_{c}^{(n)} = \sum_{p} M_{cp} Q_{p}^{(n - 1)} \\
\hat{Q}_{p}^{(n)} = \frac{1}{\sum_c M_{cp} \frac{1}{F_c^{(n - 1)}}}
\end{cases}

with normalization procedure

\begin{cases}
F_{c}^{(n)} = \frac{\hat{F}_{c}^{(n)}}{<\hat{F}_{c}^{(n)}>}_c \\
Q_{p}^{(n)} = \frac{\hat{Q}_{p}^{(n)}}{<\hat{Q}_{p}^{(n)}>}_p
\end{cases}

$F_c^{n}$ is the fitness of country $c$ in iteration $n$ and $Q^{(n)}_p$ is the complexity of product $p$ and iteration $n$. $M$ is the country-product RCA matrix. It is usually defined as a binary matrix, but it does not have to be.

The starting conditions (at iteration 0) is defined as $F^{0}_c = Q^{0}_c = 1 \forall c, p$. That is, the starting conditions for $F_c$ and $Q_p$ is just a vector of 1's that has the same length as the number of countries or products respectively.

** Implementation
*** F hat:
The equation for $\hat{F}_c^{(n)}$ is simple. Each product RCA value in $M$ should be weighted by their complexity values ($Q_p$). We then just take the sum of each countries complexity weighted RCA and get a vector of country values. This is $\hat{F}^{(n)}_c$. Computationally, this is simple: we can simply just take a matrix-vector multiplication between $M_{cp}$ and the previous iterations $Q_p$.

$$\begin{bmatrix}
m_{11} & m_{12} & m_{13}  \\
m_{21} & m_{22} & m_{23}  \\
\end{bmatrix} \times
\begin{bmatrix}
q_{11} \\
q_{21} \\
q_{31}
\end{bmatrix} = \begin{bmatrix}
m_{11}q_{11} + m_{12}q_{21}  + m_{13}q_{31}   \\
m_{21}q_{11}  + m_{22}q_{21}  + m_{23}q_{31}   \\
\end{bmatrix}$$

Using real numbers, we get:

$$\begin{bmatrix}
11 & 12 & 13  \\
21 & 22 & 23  \\
\end{bmatrix} \times
\begin{bmatrix}
11 \\
21 \\
31
\end{bmatrix} = \begin{bmatrix}
11 \cdot 11 + 12 \cdot 21  + 13 \cdot 31   \\
21 \cdot 11  + 22 \cdot 21  + 23 \cdot 31   \\
\end{bmatrix} = \begin{bmatrix}
121 + 252 + 403 \\
231 + 462  + 713  \\
\end{bmatrix} = \begin{bmatrix}
776 \\
1406  \\
\end{bmatrix}$$

To see that this works in R, first I define M:

#+BEGIN_SRC R :session test :exports both

M <- matrix(
  c(11, 12, 13,
    21, 22, 23),
  ncol = 3,
  nrow = 2,
  byrow = TRUE
)
#+END_SRC

#+RESULTS:

then Q:
#+BEGIN_SRC R :session test :exports both
Q <- c(11, 21, 31)
#+END_SRC

#+RESULTS:
| 11 |
| 21 |
| 31

And then the calculation:

#+BEGIN_SRC R :session test :exports both
M %*% Q
#+END_SRC

#+RESULTS:
|  776 |
| 1406 |

Voila. I therefor implement the equation to $\hat{F}^{n}_c$ as:

#+BEGIN_SRC R
F_hat <- M %*% Q
#+END_SRC

*** Q hat:

We can use the same basic idea for $\hat{Q}_{p}^{n}$. We first divide the scalar 1 by the $F^{n - 1}_c$  vector, then matrix-vector multiply $M_{cp}$ with the resulting vector. Finally we just divide outcome vector by the scalar 1 one more time.

To see that it works:

$$ 1 / \begin{bmatrix}
f_{11} \\
f_{21}
\end{bmatrix} \rightarrow 1 / \begin{bmatrix}
11 \\
21
\end{bmatrix} = \begin{bmatrix}
1/11 \\
1/21
\end{bmatrix} = \begin{bmatrix}
0.09 \\
0.05
\end{bmatrix} $$

and in R:

#+BEGIN_SRC R :session test :exports both
F <- c(11, 21)
round(1/F, 2)
#+END_SRC

#+RESULTS:
| 0.09 |
| 0.05 |

I now need to weight each product with the country-fitness values of the countries that export them ($M_{cp} \frac{1}{F^{n - 1}_c}$). That is, the vector $\frac{1}{F^{n - 1}_c}$ needs to be multiplied column-wise into M. Essentially, I want the whole first row of M to be multiplied by the fitness of the country in the first row, the whole second row to be multiplied by the fitness of the second country, and so on. I then want to sum each column, so that the resulting vector becomes the same length as the number of products, where the first value is the sum of the fitness of all countries exporting the first product, and so forth.

This means that we must first transpose M so that dimensions fit:

\[
M^t \times (1 / F_c) = \begin{bmatrix} 11 & 21 \\
12 & 22 \\
13 & 23
\end{bmatrix} \times (1 / \begin{bmatrix}
11 \\
21
\end{bmatrix}) = \begin{bmatrix} 11 \cdot (1 / 11) + 21 \cdot (1 / 21) \\
12 \cdot (1 / 11) + 22 \cdot (1 / 21) \\
13 \cdot (1 / 11) + 23 \cdot (1 / 21)
\end{bmatrix} = \begin{bmatrix}  2  \\
2.14 \\
2.28 \end{bmatrix}
\]

Now each product is weighted by the country that exports it, and is summed column-wise in the original M (i.e. product wise).

In R:

#+BEGIN_SRC R :session test :exports both
F <- c(11, 21) # two countries in M
round(t(M) %*% (1/F), 2)
#+END_SRC

#+RESULTS:
|    2 |
| 2.14 |
| 2.28 |

I therefor implement the equation to $\hat{Q}^{n}_p$ as:

#+BEGIN_SRC R
Q_hat <- 1 / (t(M) %*% (1/F))
#+END_SRC

*** Normalization:
The normalization procedure is simple enough. Each fitness value is divided by the average fitness value of the current iteration, and each complexity value is divided by the average complexity value of the current iteration.

For a sample $\hat{F}$ of $[11, 21, 31]$, we simply take the average and divide it into the vector. For the $\hat{F}$ from before, the average is $(11 + 21 + 31) / 3 = 21$. The new F is then:
$$ \begin{bmatrix} 11 / 21 & 21 / 21 & 31 / 21 \end{bmatrix} = \begin{bmatrix} 0.52 & 1 & 1.48 \end{bmatrix} $$

In R:

#+BEGIN_SRC R :session test :exports both
F_hat <- c(11, 21, 31)

F <- F_hat / mean(F_hat)

round(F, 2)
#+END_SRC

#+RESULTS:
| 0.52 |
|    1 |
| 1.48 |

The normalisation procedures are therefor:

#+BEGIN_SRC R
Q <- Q_hat / mean(Q_hat)
F <- F_hat / mean(F_hat)
#+END_SRC

** Coding
I now put the elements from above together in a function. N is the number of iterations, M is the RCA matrix. The M matrix should have product names as colnames and country names as rownames. I use two matrices to collect the results. The first matrix is an N times C matrix, where each column is a country and each row is an iteration number. The elements are the fitness of the country in the given iteration. The second matrix is the equivalent matrix for products.

- [X] Collection of all iteration results (for covergence graph)
- [X] Define return frame

#+BEGIN_SRC R
fitness2012 <- function(M, N) {

  # NA values introduce all sorts of problems. These are not allowed in the M matrix
  if(sum(is.na(M) != 0) {
  stop("M contains NA values. This makes things funky. Stopping.")
  }

  # define konstants
  ## number of countries
  C <- nrow(M)
  ## number of products
  P <- ncol(M)

  # define collection matrices
  country_matrix <- matrix(NA, ncol = C, nrow = N, dimnames = list(1:N, rownames(M)))
  product_matrix <- matrix(NA, ncol = P, nrow = N, dimnames = list(1:N, colnames(M)))

  # starting conditions
  F <- rep(1, C)
  Q <- rep(1, P)

  # Loop starts
  for(i in 1:N) {

    F_hat <- M %*% Q
    Q_hat <- 1 / (t(M) %*% (1/F))

    # Normalize
    F <- F_hat / mean(F_hat)
    Q <- Q_hat / mean(Q_hat)

    country_matrix[i, ] <- F
    product_matrix[i, ] <- Q
  }

  # Make country_matrix into a long, tidy data frame
  country_long <- country_matrix %>%
    as_tibble() %>%
    rownames_to_column(var = "iteration") %>%
    gather(-iteration, key = "name", value = "value") %>%
    mutate(entity = "country",
           metric = "fitness")

  # Make product_matrix into a long, tidy data frame
  product_long <- product_matrix %>%
    as_tibble() %>%
    rownames_to_column(var = "iteration") %>%
    gather(-iteration, key = "name", value = "value") %>%
    mutate(entity = "product",
           metric = "complexity")

  # Join the two long data frames and return them
  return_tbl <- rbind(country_long, product_long)

  return(return_tbl)
}

#+END_SRC

* TODO Fitness algorithm 2018
The 2018 version of the fitness algorithm was developed to avoid certain

* TODO Method of Reflections
The Method of Reflections was developed in cite:hidalgo_building_2009.

\begin{align}
k^{(n)}_c &= \frac{1}{k^{(0)}_c} \sum^{N_p}_{p = 1} M_{cp}k^{(n - 1)}_p \\
k^{(n)}_p &= \frac{1}{k^{(0)}_p} \sum^{N_c}_{c = 1} M_{cp}k^{(n - 1)}_c \\
k^{(0)}_c &= \sum^{N_p}_{p = 1} M_{cp} \\
k^{(0)}_p &= \sum^{N_c}_{c = 1} M_{cp}
\end{align}




bibliography:../writing/humgeo_thesis.bib
bibliographystyle:humnnat

* To-do
- [ ] Code RCA (fix divide by 0 problem)
- [ ] Code RCApc
- [ ] Lav rca by complexity measure (for each algortihm). Simple graph + linear function
  - [ ] Method of reflections
  - [ ] Fitness2012
  - [ ] Fitness2018
- [ ]
- [ ] Set up trade unit values
- [ ] Set up REA
