#+TITLE: Algorithms
#+AUTHOR: SÃ¸ren Post
#+LATEX_HEADER: \setlength{\parskip}{1em} % set spaces between paragraphs to 1 character
#+LATEX_HEADER: \setlength{\parindent}{0em} % set indents for new paragraphs to 0
#+LATEX_HEADER: \usepackage{natbib}
#+LATEX_HEADER: \usepackage[a4paper, total={6in, 8in}]{geometry}
#+SETUPFILE: ./org-html-themes/setup/theme-readtheorg.setup
* DONE Revealed Comparative Advantage per capita
** DONE Description
The per capita version of the RCA substitutes the reference distribution with population. That is, the RCA instead measures a countries export value per capita for a product divided by the global export value of the product per capita (ie. world population). There is a few benefits of this. First, it lessons the importance of price movements in a few products having large effects on the RCA of others (it is still not completely removed). Second, on a more practiacal note, it removes the divide-by-zero problem in the traditional equation.

Revealed Comparative Advantage per capita ($RCA^{pc}$) for country $c$ in product $p$ is defined as fined as:

$$ RCA_{cp}^{pc} = \frac{X_{cp}}{pop_c} / \frac{\sum_c X_{cp}}{\sum_c pop_c} $$

where $X_{cp}$ is a country by product matrix where the elements is the dollar amount of exports a country exports of a product (in the given year). $pop_c$ is the total population in the given year.

We implement the formula rather simply. First we build the $X_{cp}$ matrix and divide the $pop_c$ vector into it column wise (so that each countries exports are divided by its population). This gives us a population adjusted version of the $X_{cp}$ matrix. Next we take the column sums $X_{cp}$. This gives us a $p$-length vector of total global exports for each product. This vector is divided by the totalt global population. Now we have a country by product adjusted export matrix and a population adjust total export vector. Now remains just to divide the adjusted export matrix by the adjusted global export vector product wise.

Thus, if we take red wine as an example, the $RCA^{pc}$ measures the ration between a country's export of red wine divided the country's population, and the global export of red wine divided by the global population.

** DONE Implementation
First I create a sample X matrix.

#+BEGIN_SRC R :session rca :exports both
set.seed(1)

X <- matrix(
  round(runif(12, 1, 100), 0),
  ncol = 4,
  nrow = 3,
  dimnames = list(c("c1", "c2", "c3"), c("p1", "p2", "p3", "p4"))
  )

#+END_SRC

#+RESULTS:
| 27 | 91 | 95 |  7 |
| 38 | 21 | 66 | 21 |
| 58 | 90 | 63 | 18 |


and a sample population vector.

#+BEGIN_SRC R :session rca :exports both
set.seed(1)
pop_vec <- round(runif(3, 30, 100), 0)
#+END_SRC

#+RESULTS:
| 49 |
| 56 |
| 70 |

I then find the population adjusted X matrix. Because I just need to multiply the vector into the X matrix (and not sum it afterwards), I cannot do straight up matrix-vector multiplication. I therefor turn pop into a matrix, POP, with the same dimensions as X, where each column is the current pop vector.

$$ pop = \begin{bmatrix} 49 \\ 56 \\ 70 \end{bmatrix} \rightarrow POP =  \begin{bmatrix} 49 & 49 & 49  & 49\\ 56 & 56 & 56 & 56\\ 70 & 70 & 70 & 70 \end{bmatrix} $$

Thus, when I divide $X_{cp}$ with $POP$, I get the following:

$$ \frac{X_{cp}}{POP} =  \begin{bmatrix} 27 & 91 & 95 & 7 \\ 38 & 21 & 66 & 21 \\ 58 & 90 & 63 & 18 \end{bmatrix} / \begin{bmatrix} 49 & 49 & 49  & 49\\ 56 & 56 & 56 & 56\\ 70 & 70 & 70 & 70 \end{bmatrix} = \begin{bmatrix} 27 / 49  & 91 / 49 & 95 / 49 & 7 / 49 \\ 38 / 56  & 21 / 56  & 66 / 56  & 21 / 56  \\ 58 / 70 & 90 / 70 & 63 / 70 & 18 / 70 \end{bmatrix} = \begin{bmatrix} 0.55 & 1.86 & 1.94 & 0.14 \\ 0.68 & 0.38 & 1.18 & 0.38 \\ 0.83 & 1.29 & 0.9 & 0.26 \end{bmatrix} $$

In R:

#+BEGIN_SRC R :session rca :exports both
POP_mat <- matrix(pop_vec,
                  ncol = 4,
                  nrow = 3,
                  byrow = FALSE)


round(X / POP_mat, 2)
#+END_SRC

#+RESULTS:
| 0.55 | 1.86 | 1.94 | 0.14 |
| 0.68 | 0.38 | 1.18 | 0.38 |
| 0.83 | 1.29 |  0.9 | 0.26 |

I now turn to the denominator. First I create the global product vector by taking the column sums of the original $X_{cp}$. I then just sum the $pop$ vector to give me the global population.

\begin{align}
\sum_c X_{cp} &= \begin{bmatrix} 123 & 202 & 224 & 46 \end{bmatrix} \\
\sum_c pop_c &= 175
\end{align}

Column sums in R:

#+BEGIN_SRC R :session rca :exports both
colSums(X)
#+END_SRC

#+RESULTS:
| 123 |
| 202 |
| 224 |
|  46 |

Global population in R:

#+BEGIN_SRC R :session rca :exports both
sum(pop_vec)
#+END_SRC

#+RESULTS:
: 175

I now just divide the global export value of each product with the global population scalar:

$$ \frac{\sum_c X_cp}{\sum_c pop_c} = \begin{bmatrix} 123 / 175 & 202 / 175 & 224 / 175 & 46 / 175 \end{bmatrix} = \begin{bmatrix} 0.70 & 1.15 & 1.28 & 0.26 \end{bmatrix} $$

#+BEGIN_SRC R :session rca :exports both
round(colSums(X) / sum(pop_vec), 2)
#+END_SRC

#+RESULTS:
|  0.7 |
| 1.15 |
| 1.28 |
| 0.26 |

Now I turn to the final calculation, the division between the local product export adjusted by local population and the global product export adjusted by global population. Since the nominator is a matrix and the denominator is a vector of the products on a global scale, I turn the denominator into a matrix of identical rows. This means that each product is divided by the same factor (its global export divided by global population). Thus the vector from above is stacked on it self:

$$ \begin{bmatrix} 0.70 & 1.15 & 1.28 & 0.26 \\  0.70 & 1.15 & 1.28 & 0.26 \\ 0.70 & 1.15 & 1.28 & 0.26 \end{bmatrix} $$

#+BEGIN_SRC R :session rca :exports both
matrix(round(colSums(X) / sum(pop_vec), 2), ncol = 4, nrow = 3, byrow = TRUE)
#+END_SRC

#+RESULTS:
| 0.7 | 1.15 | 1.28 | 0.26 |
| 0.7 | 1.15 | 1.28 | 0.26 |
| 0.7 | 1.15 | 1.28 | 0.26 |

Finally, I do the element-wise division of the nominator matrix (the local export in each product divided by local population) and the denominator matrix (global export in each product divided by global population). The result is a county by product matrix containing the RCA per capita values.

\begin{align}
RCA_{cp}^{pc} &= \frac{X_{cp}}{pop_c} / \frac{\sum_c X_{cp}}{\sum_c pop_c} \\
              &=  \begin{bmatrix} 0.55 & 1.86 & 1.94 & 0.14 \\ 0.68 & 0.38 & 1.18 & 0.38 \\ 0.83 & 1.29 & 0.9 & 0.26 \end{bmatrix} / \begin{bmatrix} 0.70 & 1.15 & 1.28 & 0.26 \\  0.70 & 1.15 & 1.28 & 0.26 \\ 0.70 & 1.15 & 1.28 & 0.26 \end{bmatrix}
\end{align}

#+BEGIN_SRC R :session rca :exports both
round((round(X / POP_mat, 2)) / matrix(round(colSums(X) / sum(pop_vec), 2), ncol = 4, nrow = 3, byrow = TRUE), 2)
#+END_SRC

#+RESULTS:
| 0.79 | 1.62 | 1.52 | 0.54 |
| 0.97 | 0.33 | 0.92 | 1.46 |
| 1.19 | 1.12 |  0.7 |    1 |

And that's it.

** DONE Coding
We start with the same X matrix and pop vector as above:

#+BEGIN_SRC R :session function_test
rca_pc <- function(export_mat, population_vector) {

  # check for types
  if(!is.matrix(population_vector)) {
    stop("The population_vector is not a matrix. It needs to be a matrix with the same number of rows as the export matrix and 1 column. The rownames needs to be the country names (in the same order and format as the export matrix).")
  }

  if(!is.matrix(export_mat)) {
    stop("The population_mat is not a matrix. It needs to be a country (row) by product (col) matrix. The rownames needs to be the country names (in the same order and format as the population_vector).")
  }

  # check for NA values
  if(sum(is.na(export_mat)) != 0 | sum(is.na(population_vector)) != 0) {
    stop("NA values exist in either the export matrix or the population_vector. This is not allowed. Stopping.")
  }

  # check for the same number of countries in export matrix and population vector
  if(!identical(rownames(export_mat), rownames(population_vector))) {
    stop("The rownames of the export_mat and the population_vector are not identical. Stopping.")
  }

  # check for the dimensions of the population_vector and the export matrix
  if(ncol(population_vector) != 1 & nrow(population_vector) != nrow(export_mat)) {
    stop("The population_vector does not have the correct dimensions. It needs to be a matrix with the same number of rows as the export matrix and 1 column.")
  }

  # find local export per capita
  ## turn population vector into population matrix
  population_mat <- matrix(population_vector,
                           ncol = ncol(export_mat),
                           nrow = nrow(export_mat),
                           byrow = FALSE)

  ## Divide export matrix by population matrix element-wise
  local_pc_mat <- export_mat / population_mat


  # find global export per capita
  ## divide global exports by global population
  global_pc_vec <- colSums(export_mat) / sum(population_vector)

  ## turn global exports per capita vector into matrix
  global_pc_mat <- matrix(global_pc_vec,
                          ncol = ncol(export_mat),
                          nrow = nrow(export_mat),
                          byrow = TRUE)

  # Divide local export per capita by global export per capita
  rca_pc_mat <- local_pc_mat / global_pc_mat

  return(rca_pc_mat)
  # ending function
}
#+END_SRC

#+RESULTS:

Besides some rounding error, the results fit.

#+BEGIN_SRC R :session function_test :exports both
set.seed(1)
X <- matrix(
  round(runif(12, 1, 100), 0),
  ncol = 4,
  nrow = 3,
  dimnames = list(c("c1", "c2", "c3"), c("p1", "p2", "p3", "p4"))
)

set.seed(1)
pop_vec <- round(runif(3, 30, 100), 0)

pop_vec <- matrix(pop_vec, ncol = 1, dimnames = list(rownames(X), "1"))
export_mat <- X

rca_pc(export_mat = X, population_vector = pop_vec)

#+END_SRC

#+RESULTS:
|  0.78397212543554 |  1.60891089108911 |  1.51466836734694 | 0.543478260869565 |
| 0.965447154471545 | 0.324876237623762 | 0.920758928571429 |  1.42663043478261 |
|  1.17886178861789 |  1.11386138613861 |          0.703125 | 0.978260869565217 |

** TODO Create RCApc for HS92 data

To calculate RCApc data, we need two inputs: population data and trade data. The population data is drawn from the WDI API (through the dedicated package). The trade data is the raw data from the Harvard Dataverse after it has been filtered (see elsewhere).

I first create the RCApc data for one year. I then generalize the code in a function to be able to create it for all the years in one go.

*** RCApc for 2015
:PROPERTIES:
:header-args: :tangle tangled/rcapc2015_hs92.R :export both :results output silent
:END:
**** Prepare trade data

#+BEGIN_SRC R :session rcacp_data2015
library(tidyverse)
library(vroom)
library(here)

ref_year <- 2015

trade_data <- vroom(here("data/prepared/hs92_filtered_ti.csv"))

country_list <- trade_data %>%
  filter(time == ref_year) %>%
  distinct(region)

export_mat <- trade_data %>%
  filter(time == ref_year) %>%
  select(region, unit, intensity) %>%
  spread(key = unit, value = intensity) %>%
  column_to_rownames(var = "region") %>%
  as.matrix()
#+END_SRC

**** Prepare population data

#+BEGIN_SRC R :session rcacp_data2015
library(WDI)
library(tidyverse)

pop_raw <- WDI(country = "all", indicator = "SP.POP.TOTL", extra = TRUE) %>%
  as_tibble()

pop_mat <- pop_raw %>%
  filter(year == ref_year) %>%
  select(iso3c, pop = SP.POP.TOTL) %>%
  filter(iso3c %in% country_list$region) %>%
  arrange(iso3c) %>%
  column_to_rownames(var = "iso3c") %>%
  as.matrix()

#+END_SRC

**** Run function

First I define the function:

#+BEGIN_SRC R rcacp_data2015

rca_pc <- function(export_mat, population_vector) {

  # check for types
  if(!is.matrix(population_vector)) {
    stop("The population_vector is not a matrix. It needs to be a matrix with the same number of rows as the export matrix and 1 column. The rownames needs to be the country names (in the same order and format as the export matrix).")
  }

  if(!is.matrix(export_mat)) {
    stop("The population_mat is not a matrix. It needs to be a country (row) by product (col) matrix. The rownames needs to be the country names (in the same order and format as the population_vector).")
  }

  # check for NA values
  if(sum(is.na(export_mat)) != 0 | sum(is.na(population_vector)) != 0) {
    stop("NA values exist in either the export matrix or the population_vector. This is not allowed. Stopping.")
  }

  # check for the same number of countries in export matrix and population vector
  if(!identical(rownames(export_mat), rownames(population_vector))) {
    stop("The rownames of the export_mat and the population_vector are not identical. Stopping.")
  }

  # check for the dimensions of the population_vector and the export matrix
  if(ncol(population_vector) != 1 & nrow(population_vector) != nrow(export_mat)) {
    stop("The population_vector does not have the correct dimensions. It needs to be a matrix with the same number of rows as the export matrix and 1 column.")
  }

  # find local export per capita
  ## turn population vector into population matrix
  population_mat <- matrix(population_vector,
                           ncol = ncol(export_mat),
                           nrow = nrow(export_mat),
                           byrow = FALSE)

  ## Divide export matrix by population matrix element-wise
  local_pc_mat <- export_mat / population_mat


  # find global export per capita
  ## divide global exports by global population
  global_pc_vec <- colSums(export_mat) / sum(population_vector)

  ## turn global exports per capita vector into matrix
  global_pc_mat <- matrix(global_pc_vec,
                          ncol = ncol(export_mat),
                          nrow = nrow(export_mat),
                          byrow = TRUE)

  # Divide local export per capita by global export per capita
  rca_pc_mat <- local_pc_mat / global_pc_mat

  return(rca_pc_mat)
  # ending function
}
#+END_SRC

#+BEGIN_SRC R rcacp_data2015

rca_mat <- rca_pc(export_mat = trade_mat, population_vector = pop_mat)

#+END_SRC
*** RCApc for all years

I first prepare the population data.

#+BEGIN_SRC R

#+END_SRC

I then read in the filtered trade data.


#+BEGIN_SRC R

#+END_SRC

Now I nest the long trade data by year. This means that the ~data~ column in the nest contains each yearly observations in the same long format, but without the grouping variable (time). I now write a helper function that turns a long data frame into wide matrix, applies the RCApc function, and gathers it to a long RCA data frame again.

#+BEGIN_SRC R

#+END_SRC

Finally, I unnest and write the data.


** TODO Create RCApc for SITC92 data
*** RCApc for all years at once

1. separate into yearly data frames.
2. spread
3. apply rcapc function to each dataframe
4. gather

#+BEGIN_SRC R
#stud

trade_data <- vroom(here("data/prepared/hs92_filtered_ti.csv"))

country_list <- trade_data %>%
  filter(time == ref_year) %>%
  distinct(region)

export_mat <- trade_data %>%
  filter(time == ref_year) %>%
  select(region, unit, intensity) %>%
  spread(key = unit, value = intensity) %>%
  column_to_rownames(var = "region") %>%
  as.matrix()
#+END_SRC
